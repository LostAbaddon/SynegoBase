> Version     : 0.1.0
> Author      : LostAbaddon
> Organization: Dasein

# 项目介绍

这是一个 Nginx + Node.js/Go/Rust 的服务器框架，它主要提供以下这些服务：

1. 使用 Nginx 作为静态资源、上传和 VUE History Mode SPA 项目的服务器
2. 使用 Nginx 做反向代理，将所有其他请求转发给后台的 Node.js/Go/Rust 服务器，并将后者的反馈结果转发给请求方
3. 可以响应 HTTP、HTTPS、WebSocket、FTP、RPC、gRPC 请求，同时后台的 Node.js 等服务器还可以响应消息队列和命令行程序的 Socket 连接等
4. 后台服务器程序也可以发送 SSE（服务器端发送事件）
5. 后台服务器可以实现多节点多进程的集群响应
6. 每个进程都可以使用线程池或一次性线程的方式来进行并行响应

具体要求如下：

## 整体结构

整体分为负载均衡节点、主响应节点、服务响应节点。

用户需要以 YAML 或 JSON 格式进行配置，但同时如果没有配置项或者没有配置文件，则系统需要采用默认配置。

### 负载均衡节点

负载均衡节点是所谓网络请求的总入口，会布置 Nginx 服务，并对内部节点进行反向代理，同时需要对所有静态资源请求、上传资源请求以及 VUE SPA 项目进行支持。

- 作为静态服务器时，允许用户设置多个不同的 URL 目录（比如 `http://xxxx/static/*` 或 `https://xxxx/site/*`），每个 URL 目录都需要映射到一个本地目录。
- 作为上传资源服务器时，该节点需要将文件保存到自定目录，并将该目录下的资源文件地址发送给后台进行后续处理，同时外部和内部都可以以特定路径方位该目录下的用户上传资源。
- 作为 VUE SPA 服务器时，节点需要允许用户设置多个不同的 URL 目录，每个目录对应一个 VUE SPA 项目。
- 允许设置多个不同的 URL 目录（可以没有，可以只有一个，也可以有多个），当用户的请求满足这些 URL 目录时，反向代理到响应的后台主响应节点，并将主响应节点的返回结果转发回请求方。
- 如果上述所有 URL 目录都匹配不到，则返回 404 错误（具体看返回错误信息部分）。
- 负载均衡节点本身也可以是一个主响应节点，此时则不进行服务器间通讯或进程间通讯，而直接在进程内进行数据传递。

### 主响应节点

主响应节点负责对负载均衡节点提交的请求做出任务派发以及请求结果转发回负载均衡节点。

- 当主响应节点收到请求后，会根据具体请求 URL 从当前所有服务响应节点中根据负载均衡算法来挑选一个节点，将请求转发给它，并等待其反馈，这里的“节点”指的是一个特定计算机（用 IP 指定）上的特定响应进程（用进程 ID 指定）。
- 主响应节点需要记录每个响应服务节点对每个具体请求的响应节点的平均响应时长（记为 T），以及每个响应服务节点对每个具体请求的正在响应数（记为 N），以 I=T(N+1)，然后以先空闲后忙碌、同为空闲或同为忙碌时以 I 做升序排列，取该列表的第一位为新请求的响应节点。、
- 主响应节点也可以同时响应不来自负载均衡节点的 UDP、TCP、RPC 等等各种请求，但不响应不来自负载均衡节点的 HTTP、HTTPS、WebSocket、FTP 请求。
- 如果一项请求没有节点响应，则返回相应报错信息。
- 主节点在整个响应请求过程中，允许以中间件形式添加第三方插件，这部分需要留出对外接口，让使用本框架的用户可以自定义。
- 主响应节点本身也可以是服务响应节点，此时不进行服务器间通讯或进程间通讯，而直接在进程内进行响应。
- 当响应框架程序文件发生改变时，须要自动重启。对 Node.js 服务程序来说这点可以用 PM2 实现。

### 服务响应节点

- 服务响应节点在启动后须要通过远程通讯、进程间通讯等方式通知主响应节点（当然，并不需要向所有主响应节点）通知自己已经连线，完成服务响应注册，该握手信息总包括以下信息：
  + 自身 ID（由节点自己生成）
  + 以数组形式给出响应服务范围（以 URL 前缀来表示可以响应的服务，比如 `/users/:id` 就表示对所有 URL 为 `/users/:id/*` 的请求做出响应（其中 :id 是所有可能的字符串，并被保存到参数中的 id 变量中），这个前缀支持 URL 模式，也就是正则表达，但只响应开头部分）
  + 响应服务范围写在服务响应节点的配置文件中，如果没有相应字段或没有相应配置文件，则认为对一切服务都进行响应
- 主响应节点会定期通过心跳检测的方式来检测每个服务响应节点是否离线，同时每次派发任务的时候也会记录节点是否正常返回是否离线（这部分如果检测了，则心跳检测重置）。
- 响应实体由使用该框架的第三方来实现，本框架只负责任务派发以及对实体响应结果的处理。
- 如果有响应实体进行响应，但出错，则捕获这个错误，并返回给请求方。
- 框架传给响应实体的信息须要包括：
  + 请求方式（Web、WebSocket、UDP、TCP、Pipe，等等）
  + 请求方法（GET、PUT、POST、DEL，等等）
  + 请求 URL
  + URL 参数（即 query 参数以及诸如 `/users/:id` 中的 `id` 这样的参数）
  + 其他参数（比如 Form 数据、request body 数据，等等，这些数据的处理会很琐碎和复杂）
- 在服务响应节点的配置文件中，会给出响应实体的本地目录，如果没有的话则表示该节点为非法节点，则在启动后要自动关闭。
- 在配置文件中设置的本地目录中，保存着响应实体文件，其相对该目录的相对路径会以 Express 中注册中间件的 URL 模式的形式自动进行响应，比如：服务响应范围是 `[ "/A/", "/B/:mode/" ]`，而本地目录是 `~/api/`，其中有两个文件，目录分别是 `~/api/main.js` 和 `~/api/:id/put/index.js`，负载均衡节点中设置的 WebAPI 响应目录是 `/call`，则当用户的请求 URL 是 `https://xxxx/call/A/user/put/` 时，被激活的响应实体就是 `~/api/:id/put/index.js`，且会有一个参数 `id: user`，而当用户请求的是 `http://xxxx/call/B/test/main` 时，被激活的响应实体就是 `~/api/main.js`，且会有一个参数 `mode: test`。
  + 外部的 UDP、TCP 等请求中也会要求必须包含请求 URL 来决定调用哪个服务响应实体。
- 每个响应实体文件都必须输出一个对象，对象中包含以下信息：
  + 响应的请求方式列表，默认是所有请求方式；
  + 响应的请求方法列表，默认是所有请求方法；
  + 一个函数，用来实际处理请求；
  + 一个非负整数，表示允许同时响应多少该请求，0 表示无上限，否则响应进程需要判断当前该响应实体已经在响应多少该请求了，如果已经满负载则需要等到有请求结束响应（无论是正常还是异常，异常的话须等待响应后续异常操作结束，比如重启线程）后以 FIFO 的方式将等待中的请求发送给响应实体；
  + 一个标记，标明是非线程模式、一次性线程模式还是常驻线程模式
    * 非线程模式，则在本节点的当前进程内运行，即普通调用，可能会引起阻塞；
	  * 一次性线程模式，是在每次有请求的时候就开启一根线程，在该线程中运行该响应函数，结束或出错后强制结束该线程；
	  * 常驻线程模式，则会启动一根线程，只运行该响应函数，如果出错导致线程关闭或者响应时间超时（超时时长可在统一的配置文件中设置，默认是 30 秒），则有节点进程强制关闭该线程并重启常驻线程，同时返回响应错误给请求放。
  + 可选参数：别名，这是一个数组，让这个响应体可以响应其他 URL 模式的请求
- 需要监听每个响应实体文件，如果发生变动则要重新进行加载以及重启响应线程（即热重加载）。
- 当响应框架程序文件（而非响应实体文件）发生改变时，须要自动重启。对 Node.js 服务程序来说这点可以用 PM2 实现。
- 服务响应节点只要满足上述协议就可以向主节点注册服务，并不需要一定采用本框架。

## 其他要求

- 要提供统一的日志存储服务，记录每个节点（包含进程 ID，如果启动了线程则要有线程 ID，对集群模式还要有 IP 信息，然后还有 `YYYY/MM/DD hh:mm:ss` 格式的时间戳）的日志信息（其中内容必须包含请求 ID、日志等级日志内容等信息），并按照顺序统一写到日志文件中，日志以天为单位，并根据 error、info、log、warn 这四个级别保存为每天四个文件。Nginx 服务可以有自己的独立日志文件。
- 日志目录在配置文件中设置，默认是运行目录下的 `log` 文件夹。
- 可以从任何其他目录加载本框架，然后所有的运行目录都相对该运行位置而非框架代码所在位置。
- 需要有一个监管进程，它在发现每个机器上的服务进程挂掉后立刻自动重启。可以使用外部库，比如 PM2。
- 需要支持 Redis 和 MySQL，即在配置文件中可以设置 Redis 和/或 MySQL 的连接 URL 等配置，如果设置了则启用相应功能，否则不启用。
- 不同节点可以不通过主节点直接进行通讯。
- 可以通过另可一个命令行程序（node 启动我们提供的特定 console 程序）来接入主节点，然后通过命令行来查看服务集群当前的状态，包括：
  + 有多少响应节点（机器与进程分开列）
  + 有多少服务（多少节点响应该服务，以及该服务已被请求多少次、正在响应多少请求）
  + 静态文件读取次数
  + 上传了多少文件
  + 其他必须信息

## 返回错误信息

所有错误信息都以 JSON 格式返回：

```json
{
	code: Number,
	msg: String
}
```

其中 code 是错误编号，而 msg 是具体错误信息，用于在前端显示（是否显示由前端控制）。错误号及意义如下：

|code |意义                |
|-----|-------------------|
| 404 | 资源、响应节点没找到 |
| 500 | 服务响应出错        |

## 未来展望

- 未来会在主节点与服务响应节点之间引入 Paxos 等算法以降低主节点打来的 SPOF 危害（在目前的版本中暂不考虑）。
- 未来会引入背压（Backpressure）机制，当所有主节点和服务响应节点都达到一定负荷后，负载响应节点会返回 503 并带上 `Retry Later` 头。
